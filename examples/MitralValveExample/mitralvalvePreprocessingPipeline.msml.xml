<msml:msml xmlns:msml="http://sfb125.de/msml"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://sfb125.de/msml">

    <variables>
        <var name="input_mv_surf_mesh"
             value="XNAT_PatientData_SampleCases_Input/MVR_Sample_Patient2_Segmentation_P0097.vtp"
             logical="TriangularSurface" physical="vtp" role="input" />
        <var name="input_mv_ring"
             value="XNAT_PatientData_SampleCases_Input/MVR_Sample_Patient2_AnnuloplastyRingPhysioII32_OptimallyPlaced_P0097.vtp"
             logical="object" physical="vtp" role="input" />
    </variables>

    <scene>
        <object id="mitralvalve">
            <mesh>
                <linearTet id="mvVolMesh" mesh="${aVtuToHf3inpIncMVmatIDsProducer.inpMeshFile}"/>
                <!-- Note: .inpMeshFile not needed -->
                <!-- this mesh-representation/link is used for creating the hf3-scene-file; -->
            </mesh>

            <material>
                <region id="mvMaterial" indices="${aVtuToHf3inpIncMVmatIDsProducer.tet_material}">
                    <materialID matID="10"/>
                    <linearElasticMaterial youngModulus="2350" poissonRatio="0.488"/>
                    <!-- Note: for mitral valve tissue: youngModulus \in {2350, 4166, 6200} -->
                    <!-- NOTE: Apply machine learning algorithms here?! -->
                    <mass name="stdMass" massDensity="1.000"/>
                </region>
            </material>

            <constraints>
                <constraint name="bodyConstraint" forStep="${initial_def_implantation_1}">
                    <mvGeometryConstraint mvGeometry="${anMvGeometryAnalyzer}"/>
                    <!-- Note: this is not a "real" constraint, but allows the specific HiFlow3-MVR-Simulation to set up the specific blood-flow/pressure-BC-representation -->
                    <!-- Note: this has to be MSMLalized/standardized later -->
                    
                    <displacedPointsConstraint points="${aBCdataForMVRsimProducer.points}"
                                               displacements="${aBCdataForMVRsimProducer.displacements}"/>
                    <!-- Note: instead of using the standard msml-displacementConstraint with "indices", this new displacedPointsConstraint allows for specifying points/displacements directly -->
                    <!-- Note: these points/displacements (i.e. AnnulusPointsToBeDisplacedBySewingProcedure) come from the 'mitral'-Operator "aBCdataForMVRsimProducer" -->
                    <!-- Note: this has to be MSMLalized/standardized later -->
                    
                    <surfacePressure indices="0" pressure="0"/>
                    <!-- Note: this is empty in the MVR simulation scenario, since facet- AND point-wise Neumann-BCs are needed, and since facetwise Neumann-BCs are fixly set up on surface boundary facets with IDs in {17,18,20}. -->
                    
                    <pointwiseForceConstraint points="${aBCdataForMVRsimExtender.points}"
                                              forces="${aBCdataForMVRsimExtender.forces}"/>
                    <!-- Note: instead of using the standard msml-surfacePressureConstraint with facet-indices, this new additional surfacePointForcesConstraint allows for modeling the MV chordae pull forces -->
                    <!-- Note: these points/forces (i.e. ChordaePullForces) come from the 'mitral'-Operator "aBCdataForMVRsimExtender" -->
                    <!-- Note: this has to be MSMLalized/standardized later -->
                    
                    <!-- Note: to complete the MSML-representation of boundary constraints, we additionally need a time-dependent-surface-force-Constraint, acting on surface facets with specific matIDs (e.g. leafletsDownsideToIndexGroup)
                    and in dependence of time in order to model the directed pressure/force profile on the leaflets during the cardiac cycle -->
                    <!-- Note: this has to be MSMLalized/standardized later -->
                </constraint>
                
                <!-- <constraint name="bodyConstraint" forStep="${subsequent_def_heartcycle_2}"> -->
                <!--     ... include pointwiseForceConstraint here then ... -->
                <!-- </constraint> -->
            </constraints>

            <output>
                <displacement id="mitralvalve_disp" timestep="1" /> <!-- cp. nsofa-exporter: boolean useAsterisk="true" /> -->
            </output>
        </object>
    </scene>

    <workflow>
        <!-- <ConvertSTLToVTK id="vtkConverter" STLMesh="mitralvalveSegmentation.stl" targetFilename="mitralvalveSegmentation.vtk"/> -->
        <!-- ConvertSTLToVTK-Operator not needed anymore -->

        <SurfaceToVoxelDataOperator id="aSurfaceToVoxelsOperator" surfaceMesh="${input_mv_surf_mesh}"
                                    targetImageFilename="mvImage.vti" accuracy_level="10" smoothing="1"/>
        <!-- SurfaceToVoxelDataOperator could be replaced by DistanceMapOperator -->
        <!-- NOTE: Apply machine learning algorithms here?! -->

        <vtkMarchingCube id="aVoxelToContourOperator" image="${aSurfaceToVoxelsOperator}"
                         outFilename="mvVolumeSurface.vtk" isoValue="90"/>
        <!-- isoValue="90" is okay, "300" is optimal -->
        <!-- vtkMarchingCube could be replaced by Voxel2ContourOperator -->
        <!-- Alternative: maybe rather MSMLalize/implement own dedicated ImageToContourSurfaceMesh.py operator for this task -->
        <!-- NOTE: Apply machine learning algorithms here?! -->

        <!-- <ReduceSurfaceMesh(std::string infile, std::string outfile, int verticesCount, bool forceManifold, bool asciiOutput) -->
        <!-- ACVD_Remeshing_Operator / MeshCellNumber_Reduction_Operator -->
        <!-- ReduceSurfaceMesh/ACVDremeshing-Operator not needed anymore -->

        <CGALMeshVolumeFromSurface id="aVolumeMesher" meshFilename="mvVolumeMesh3D_CGAL.vtk"
                                   surfaceMesh="${aVoxelToContourOperator}"
                                   preserveFeatures="false" facetAngle="20" facetSize="0.4" facetDistance="0.3"
                                   cellRadiusEdgeRatio="3" cellSize="0.4" odt="false" lloyd="false" pertube="false"
                                   exude="false"/>
        <!-- facetSize="0.4" facetDistance="0.3" cellRadiusEdgeRatio="3" is okay, {0.2, 0.2, 0.2} is optimal -->
        <!-- NOTE: Apply machine learning algorithms here?! -->

        <!-- <ConvertVTKToVTU id="vtuConverter" VTKMesh="${aVolumeMesher} " targetFilename="mvVolumeMesh3D_hf3vtu.vtu"/> -->
        <!-- convertVTKbinaryToVTU not needed, since automatic conversion takes place if needed -->

        <vtuToHf3inpIncMVmatIDsProducer id="aVtuToHf3inpIncMVmatIDsProducer"
                                        volume="${aVolumeMesher}"
                                        surface="${input_mv_surf_mesh}"
                                        />
        <!-- Note: this has to be MSMLalized/standardized later -->

        <mvGeometryAnalytics id="anMvGeometryAnalyzer"
                             surface="${aVolumeMesher}"
                             ring="${input_mv_ring}"/>
        <!-- Note: this has to be MSMLalized/standardized later -->

        <mvrBCdataProducer id="aBCdataForMVRsimProducer"
                           volumeMesh="${aVolumeMesher}"
                           surfaceMesh="${input_mv_surf_mesh}"
                           ring="${input_mv_ring}"/>
        <!-- Note: this has to be MSMLalized/standardized later -->

        <mvrBCdataExtender id="aBCdataForMVRsimExtender"
                           volumeMesh="${aVolumeMesher}"
                           surfaceMesh="${input_mv_surf_mesh}" />
        <!-- Note: this has to be MSMLalized/standardized later -->

        <!-- Simulation_Scenario_Mgmt_Operator to organize/distribute MV-scenarios-->
        <!-- Simulation_Scenario_Mgmt_Operator not needed anymore, since scenario-distribution is managed via CogApps-Pipe-I/O -->

        <!-- EXECUTE_HIFLOW3_SIMULATION or PREPARE_HIFLOW3_SIMULATION_INPUT_FOR_EXECUTION -->
        <!-- Note: by using the 'hiflow3' or 'mitral' exporter, the simulation is
             - either executed (sequentially or in parallel via 'mpirun -np X')
             - or only prepared for execution (by writing out the input data and the exec command line into a script file),
               e.g. for a job on a HPC-cluster). -->

        <!-- pvtu2vtu-Operator -->
        <!-- pvtu2vtu-Operator not needed anymore, since pvtu2vtu-conversion is done in vonMisesStressComputation-Operator via CogApps-Pipe-I/O -->

        <!-- VonMisesStressVisualization_PostProcessing_Operator -->
        <!-- <vonMisesStressComputation_mvrPostProcessingAnalytics id="aVonMisesStressComputingOperator" path_to_sim_results="${mitralvalve_disp}"
                       matParam_Lambda="284666" matParam_Mu="700" mvMeshDeformedWithVonMisesStressData="_SimResults_with_vMstressVis_" /> -->
        <!-- ${hf3Simulation/SimResults}" or "/out_mitralvalvePreprocessingPipeline.msml/SimResults" -->
        <!-- vonMisesStressComputation_mvrPostProcessingAnalytics operator not needed anymore, since executed via CogApps-Pipe-I/O -->
        <!-- in case of integration into MSML: include simulation results in MSML pipeline via using the msml.scene.output-tag-id -->
        <!-- in case of integration into MSML: execute script for simulation results of all timesteps (and set according naming w.r.t. ts_) -->
    </workflow>

    <environment>
        <solver linearSolver="CG" preconditioner="SGAUSS_SEIDEL" hf3_chanceOfContactBoolean="1"
                processingUnit="CPU" numParallelProcessesOnCPU="0"
                timeIntegration="Newmark" dampingRayleighRatioMass="0.5" dampingRayleighRatioStiffness="0.5"/>
                <!-- use numParallelProcessesOnCPU="0" in order not to run simulation but to only produce the simulation input files --> 
        <simulation>
            <step name="initial_def_implantation_1" dt="0.05" iterations="400" visualizeSimResultsEvery1inXtimesteps="5" />
            <!-- <step name="initial_def_implantation_1" dt="0.05" iterations="20"/> -->
            <!-- <step name="subsequent_pause" dt="0.05" iterations="20"/> -->
            <!-- <step name="subsequent_def_heartcycle_2" dt="0.01" iterations="500"/> -->
            <!-- <step name="subsequent_blood_pressure_and_mv_closing" dt="0.01" iterations="500"/> -->
        </simulation>
    </environment>

</msml:msml>
